{\rtf1\ansi\ansicpg1252\cocoartf949\cocoasubrtf540
{\fonttbl\f0\fnil\fcharset0 Monaco;}
{\colortbl;\red255\green255\blue255;\red191\green0\blue0;\red0\green0\blue191;\red96\green96\blue96;
\red0\green115\blue0;}
\pard\tx560\tx1120\tx1680\tx2240\tx2800\tx3360\tx3920\tx4480\tx5040\tx5600\tx6160\tx6720\ql\qnatural\pardirnatural

\f0\fs26 \cf2 //cheerful and ethereal\cf0 \
z = \cf3 Server\cf0 .internal;\
\
\cf3 SynthDef\cf0 (\cf4 "just-sine"\cf0 ,\{\cf3 |freq=100,freq2=50, atk=1, rel=1, sus=1, amp=0.005,pan =0,gate=0|\cf0 \
	\cf3 Out\cf0 .ar(0,\cf3 Mix\cf0 .ar(\cf3 Pan2\cf0 .ar(\cf3 FSinOsc\cf0 .ar( [1,1] * freq,0,48*amp / (16+freq/freq.log)),pan)) * \cf3 EnvGen\cf0 .ar(\cf3 Env\cf0 .perc(atk,rel, 1, sus),gate, doneAction:2) );\}).load(z);\
\
\
~clock = \cf3 TempoClock\cf0 .new(1/2,0,0,16384);\
~clock.tempo_(2.5);\
\cf2 /* start at 0 step 1 mod 2**14, then 2**14 step 2, 2**15 step 4, 2**16, step 8\
2**17 step 16\
3**10 step 81\
3600 *15 step 60\
11**3 step 121\
*/\cf0 \
~i= (2**15).asInt;\
~r = \cf3 Routine\cf0  \{\
	\cf3 var\cf0  th = 	(3..12).collect(3**\cf3 _\cf0 );	\
	((2**15)).asInt.do(\{\cf3 |z|\cf0 \
		\cf3 var\cf0  i=~i;\
\
		~play.value(i.asInt,z.asInt);\
		~i = ~inc.value(i.asInt);\
		\cf4 "z: "\cf0 .post;\
		z.postln;\
	\});\
240.wait;\
z.freeAll;\
\};\
\cf2 //i + 16,15,14...at largest ill\cf0 \
\cf2 //3600 * hour, step hour * 60\cf0 \
\cf2 //3600*15 step 60\cf0 \
~inc = \{\cf3 |i|\
	var a = \cf0 ((2**(i.log10.ceil-2)) * (3**(i.log10.ceil-3))* (5**(i.log10.ceil-5)));\
\cf3 	a = \cf0 ((2**(i.log10.ceil)));\
	(i+a).asInt;\
\};\
\
~w = [  \
	\{\cf3 |p,i|\cf0 (p.log2.ceil/p.log2.nextPowerOfTwo)\},\
	\{\cf3 |p,i|\cf0 (p/p.nextPowerOfTwo)\},\
\
	];\
\
~play = \{\cf3 |i|\cf0 \
		\cf3 var\cf0  il,ill,r,w,hf,ii;\
		ii=i;\
		il = (\{\cf3 |x|\cf0 ((2**x)*(i/(2**x)%2).floor)\}!i.log2.ceil.asInt);\
		ill = (1+il).log2.floor;\
		ill.postln;\
		il.postln;\
		i.postln;\
		hf = ill.reverse.wrapAt(i.log10.ceil);\
		hf.postln;\
		w = ~w.wrapAt(ill.reverse.wrapAt(i.log10-3));\
		(\{|i|i\}!~w.size).wrapAt(ill.reverse.wrapAt(i.log10-3)).postln;\
		i=(il.sort.reverse[0] + il.sort.reverse.wrapAt(i.log10-1) +(i%il.sort.reverse.wrapAt(i.log10+1))+ (i%il.sort.reverse.wrapAt(i.log10-2))).ceil.asInt;\
		i.postln;\
		i.factors.postln;		\
		r = \cf3 Routine\cf0  \{\
		i.factors.do(\{\cf3 |p,j|\cf0 \
			\cf3 var\cf0  rr = \cf3 Routine\cf0  \{\
				(p.log2).ceil.asInt.do(\{\cf3 |k|\cf0 \
				w.(p,i).wait;\
				(p.log10.ceil).asInt.do(\{\cf3 |l|\cf0 \
					\cf3 var\cf0  s,freq;\
					s = \cf3 Synth\cf0 (\cf4 "just-sine"\cf0 );\
					p=p.nextPowerOfTwo;\
				\
					freq =((p *(2**((i.log2.ceil %4)+i.log10.floor) )*(([(\{\cf3 |j|\cf0 j=(2*j)+1+(i.log2.ceil%2); (j/j.nextPowerOfTwo)\}!( hf)),1]).flat *.x[16,20,24,30,36,45,54].permute(i) * [1,9/8].wrapAt(ill.sort.wrapAt(i.log.floor-1)) /16).flat.permute(ii).wrapAt(l+j+k+p  ) * (2**i.factors.size)) * (1/2**l));\
					\
					(freq > (2**14)).if (\{freq = freq * (1/(2**8))\});\
					(freq > (2**14)).if (\{freq = freq * (1/(2**8))\});\
					(freq > (2**14)).if (\{freq = freq * (1/(2**7))\});\
					(freq > (2**14)).if (\{freq.postln; freq = freq * (1/(2**7))\});\
\
					(freq < (2**7)).if (\{freq = freq * 2\});\
					(freq > 192).if(\{freq = freq + (\{\cf3 |i|\cf0 i * (2.5/8)\}!i.log2.ceil.asInt).wrapAt(k+j+i+l)\});\
\
					s.set(\cf5 \\freq\cf0 , freq);\
					s.set(\cf5 \\rel\cf0 ,((24+l)/p.log.ceil)/i.log10);\
					s.set(\cf5 \\pan\cf0 ,(1/(i.factors[j])) * (-1**(i+j+k+l)));\
					s.set(\cf5 \\atk\cf0 ,(1/freq**0.5) * (i.factors[j]/i.log10) * (1/(i.log*2)));\
					s.set(\cf5 \\atk\cf0 ,(1/freq**0.5) * (i.factors[j].sqrt *i.log10) * (1/(i.log*2)));\
\
					s.set(\cf5 \\sus\cf0 ,-1 * i.factors[j].log2);\
					s.set(\cf5 \\gate\cf0 ,1);\
					s.set(\cf5 \\amp\cf0 ,(((1/((p-(0.3)).log10)) * 0.005 / ((k/p.log10.ceil)+1))*i.factors[j].sqrt)/(l+1));\
					\});\
				\});\
			\};\
			~clock.play(rr,0);\
			\});\
		\};\
		~clock.play(r,0);\
		(1/2).wait;\
\};\
\
\
\
\
\
\
\
\
\
\
\
\
\
\
~clock.play(~r,0);\
z.scope;\
}